'keydown' - Kada stisnemo taster nesto se izvrsi
'keypress' - konstantno dok drzimo taster nesto se izvrsava			
'keyup' - Kada pustimo taster nesto se izvrsi

// SCOPE //

Call stack - Place where execution contexts get stacked on top of each
other, to keep track of where we are in execution

Scoping asks the question Where do variables live? or Where can we access
a certain variable, and where not

there are 4 types of scope in JS: The Global scope, scoped defined by function
and scopes defined by blocks(if, for loop)

let i const su blocke-scoped
var je function-scoped

In JS we have lexical scoping, so the rules of where we can acces a variable 
are based on exactly where in the code functions and blocks are written


child scope ima informacije parent scope, ali nikad ne moze biti obrnuto. Ovo je
scope chain

When a variable is not in the current scope. the engine looks up in the scope 
chain until it finds the variable its looking for. This is called
variable lookup

The scope chain is a one-way street: a scope will never, ever have acces
to the variables of an inner scope

The scope chain has nothing to do with the order in which functions are called. 
It does not affect the scope chain at all

// This keyword: Special variable that is created for every execution context(every function). Takes the value of (points to) the 'owner' of the function in which this keyword is used

This is NOT static. It depends on how the function is called and its value is only assigned when the function is actually called

When function is called as:
Method - this = Object that is calling the method

Simple function call - this = undefined (In strict mode otherwise: window(in the browser))

Arrow functions (dont get own this) - this = this of surrounding function(lexical this)

Event listener - this = DOM element that the handler is attached to