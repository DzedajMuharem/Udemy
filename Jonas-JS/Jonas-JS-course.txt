Vrste funkcija: 

Dot vs Bracket

we use object.something when somethnig actually exists in object
if for example we had 
const objectBracket = prompt('Napis nesto)
then we would use object[objectBracket] beacuse we dont have variable called objectBracket in object but we have the value of the prompt as the variable in object
// Function declaration
function nazivFunkcije(parametar) {
  return 2037 - parametar;
}

// Function expression
const nazivFunkcije = function (parametar) {
  return 2037 - parametar;
};

// Arrow function
const nazivFunkcije = (parametar) => 2037 - parametar;

// Pozivanje funcikije
const pozivanjeFunkcije = nazivFunkcije(argument);

------------------------------------------------------------------------------------------------------------------
// How JS works behind the scenes //

--Java script is:
1. HIGH-LEVEL language, where we do not have to manage resources at all because these languages have so-called abstractions that take all of that work away from us. This makes the language easier to learn and to use, but the downside is that programs will never be as fast or as optimized as for example, C programs.

2. Now, one of the powerful tools that takes memory management away from us developers is GARBAGE-COLLECTION, which is basically an algorithm inside the JavaScript engine, which automatically removes old, unused objects from the computer memory in order not to clog it up with unnecessary stuff.

3. an interpreted or just-in-time compiled language.

4. Now, one of the things that makes JavaScript so popular is the fact that it's a multi-paradigm language. In programming, a paradigm is an approach and an overall mindset of structuring our code, which will ultimately direct the coding style and technique in a project that uses a certain paradigm.
Now, three popular paradigm:
are procedural, object-oriented, and functional programming.

5. So, about the object-oriented nature of JavaScript, it is a prototype-based, object-oriented approach. Well, first, almost everything in JavaScript is an object, except for primitive values such as numbers, strings, et cetera. But arrays, for example, are just object. Now, have you ever wondered why we can create an array and then use the push method on it, for example? Well, it's because of prototypal inheritance. Basically, we create arrays from an array blueprint, which is like a template and this is called the prototype. This prototype contains all the array methods and the arrays that we create in our code then inherit the methods from the blueprint so that we can use them on the arrays.

6. JavaScript is a language with first-class functions, which simply means that functions are treated just as regular variables. So, we can pass functions into other functions and we can even return functions from functions.

7 .JavaScript is a dynamic language and dynamic actually means dynamically-typed. So as we've already seen, in JavaScript, we don't assign data types to variables. Instead, they only became known when the JavaScript engine executes our code. Also, the type of variables can easily be changed as we reassign variables. 

8. But anyway, let's now finally talk about the single-thread and the non-blocking event loop concurrency model.
First, what actually is a concurrency model? Well, it's just a fancy term that means how the JavaScript engine handles multiple tasks happening at the same time. JavaScript itself runs in one single-thread, which means that it can only do one thing at a time and therefore we need a way of handling multiple things happening at the same time.
So basically, the thread is where our code is actually executed in a machine's processor. But what if there is a long-running task, like fetching data from a remote server? Well, it sounds like that would block the single thread where the code is running, right? But of course we don't want that. What we want is so-called non-blocking behavior and how do we achieve that? Well, by using a so-called event loop. The event loop takes long-running tasks, executes them in the background and then puts them back in the main thread once they are finished.

-- Execution Contexts and The Call Stack
Well, an execution context is an abstract concept. But I define it basically as an environment in which a piece of JavaScript is executed. It's like a box that stores all the necessary information for some code to be executed. Such as local variables or arguments passed into a function. So, JavaScript code always runs inside an execution context.

Call stack - Place where execution contexts get stacked on top of each
other, to keep track of where we are in execution

-- Scope and The Scope Chain
Scoping asks the question Where do variables live? or Where can we access
a certain variable, and where not

there are 4 types of scope in JS: The Global scope, scoped defined by function
and scopes defined by blocks(if, for loop)

let i const are blocke-scoped
var is function-scoped

In JS we have lexical scoping, so the rules of where we can acces a variable 
are based on exactly where in the code functions and blocks are written
 **Scope chain - Child scope has the acces to the information of the parent scope, but parent scope can never have acces to the information of the child scope.

When a variable is not in the current scope. the engine looks up in the scope 
chain until it finds the variable its looking for. This is called
variable lookup

The scope chain has nothing to do with the order in which functions are called. 
It does not affect the scope chain at all

--This keyword 
Special variable that is created for every execution context(every function). Takes the value of (points to) the 'owner' of the function in which this keyword is used
 
This is NOT static. It depends on how the function is called and its value is only assigned when the function is actually called

When function is called as:

Method - this = Object that is calling the method
Simple function call - this = undefined (In strict mode otherwise: window(in the browser))
Arrow functions (dont get own this) - this = this of surrounding function(lexical this)
Event listener - this = DOM element that the handler is attached to

-----------------------------------------------------------------------------------------------------
// Data Structures, Modern Operators and Strings //

-- Destructuring arrays
So destructuring is an ES6 feature and it's basically a way of unpacking values from an array or an object into separate variables. So in other words destructuring is to break a complex data structure down into a smaller data structure like a variable.

const arr = [2, 3, 4];
const [x, y, z] = arr;

//destructuring inside of destructuring
const [i, , [j, k]] = nested;
console.log(i, j, k);

-- Destructuring objects
To destructure objects we use the curly braces.
What we have to do is to provide the variable names that exactly match the property names that we want to retrieve from the object.
The order of the elements doesnt matter
const { name, openingHours, categories } = restaurant;


If we wanted variable names to be different:
const {
  name: restaurantName,
  openingHours: hours,
  categories: tags,
} = restaurant;
We do it like this. First we put the real property name and then : and we write the name we want

// Default values
const { menu = [], starterMenu: starters = [] } = restaurant;
menu will be equal to [] beacuse it doenst exist, we created it, and starters will be equal to its real value. So the default value will only be applied if there is no real value

// Mutating variables
let a = 111;
let b = 99;
const obj = { a: 23, b: 7, c: 14 };
({ a, b } = obj);

{ a, b } = obj - You cant start line of code with { beacuse JS excepts code block, so we put everrything in () like this
({ a, b } = obj)

// Nested Objects

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
}

const {
  fri: { open: o, close: c },
} = openingHours;
console.log(o, c);

// If we pass object as the argument then the function will immediately destructure tha object
const deliverObject = {
  time: '23:30',
  mainIndex: 2,
  starterIndex: 2,
}

const restaurant = {
 orderDelivery: function ({
    starterIndex = 1,
    mainIndex = 0,
    time = '20:00',
    
  }) {
    console.log(
      `Order recieved: ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be at ${time}`
    );
  },
}

restaurant.orderDelivery(deliverObject); -- We can also put variables directly into the function like this:
restaurant.orderDelivery({
  time: '23:30',
  mainIndex: 2,
  starterIndex: 2,
})

So in restaurant object we have orderDelivery function with default values. When calling it we can put the new values, or we can leave the default values by not writing the variable


-- Spread operator (...)
What the spread operator does is to basically take all the values
out of array, and then write them individually
We can use the spread operator whenever we would otherwise write multiple values separated by commas.
We can use the spread operator when we pass arguments into functions.

Spread operator takes all the element from the array
and it also deasnt create new variables. And as a consequence, we can only use it in places
where we would otherwise write values separated by commas

Spread operator works on all Iterables
Iterables are arrays, strings, maps, and sets, but not objects

-- Rest pattern (...)
Rest pattern basically collects the elements that are unused in the destructuring assignment.
Rest is found on the left side of the = sign
const [a, b, ...others] = [1, 2, 3, 4, 5];

Rest pattern compreses all values it gets into an array(It works opposite of spread operator)

-- Short circuiting (&& ||)
&& (and) looks if every value is truthy, if not, then it will print out first falsy value
console.log(23 && 'string' && 0 && 'Hello')
It will print out 0 beacuse that is the first falsy value
If there are no falsy values then it will print out last truthy value it encounters

||(or) looks if there are any truthy values if there are it will print the first one it encounters
console.log(23 && 'string' && 0 && 'Hello')
Here it will print out 23 beacuse that is the first truthy value it encounters

-- The Nullish Coalescing Operator (??)
Nullish values: null and undefined (NOT 0 or '')

const nullishCoalescingOperator = false ?? 10
Here we will get nullishCoalescingOperator = false beacuse nullish operator will act like false is actually truthy value
If Instead Of false we had null or undefined value then the outcome would be 10

-- Logical Assignment Operators

let variableOr = 10 > 4 || 'Team 1 ima vise sansi za pobedu';
Here the value of variableOr will be true beacuse 10>4 is true 

let variableAnd = 4 < 10 && 'Team 2 ima vise sansi za pobedu';
Here the value will be 'Team 2 ima vise sansi za pobedu' beacuse there are no falsy values, and last truthy is the given string sto that will be its value

let message = variableOr || variableAnd;
Here the value will be the same value as the variableOr because it is the first truthy value it encounters

-- Optional chaining (?.)
If soemthing doesnt exist it retunrs undefined

if (restaurant.openingHours && restaurant.openingHours.mon)
  console.log(restaurant.openingHours.mon.open);

  console.log(restaurant.openingHours.mon?.open);
console.log(restaurant.openingHours?.mon?.open);

optional chaining and nullish Coalescing operator almost always go together

-- Object Keys, Values, Entries
Object.keys gives us the name of the property
Object.values gives us the value of the property
object.entries gives us the entire object (both the name and the value of property)

-- Sets
Set is basically just a cloection of unique values, so that means that sets cannot have any duplicates.
In sets there are no indexes and there is no way of  getting that values since it doesnt exists

-- Maps
A map is a data structure that we can use to map values to keys.
Like in objescts data is stored in key value in maps.
Differnece is that in maps, the keys can have any type.(In objects keys are basically always strings)

-- Which Data Structure to Use?
where data can actually come from. So there are essentially three sources of data.

- First, the data can be written within the program source code itself like status messages that will be displayed on a webpage based on user actions.
- Second, data can come from the user interface. So from the webpage, it can either be data that the user inputs into some form or data test already written somehow in the DOM.

- Finally, data can come from external sources which is usually a web API.

So the first decision is this do we just need a simple list of values? If so, then we're gonna use an array or a set. But on the other hand if we need key value pairs, then we need an object or a map.

Arrays vs Sets
Now you should use arrays whenever you need to store values in order and when these values might contain duplicates. Also you should always use arrays when you need to manipulate data because there are a ton of useful array methods.

Now sets on the other hand should only be used when you are working with unique values, besides that you can also use sets in situations when high performance is really important because operations like searching for an item or deleting an item from a set can be up to 10 times faster in sets than in arrays.

Objects vs Maps
You should use maps when you simply need to map keys to values and also when you need keys that are not strings because as we saw in the last video, that can be very powerful sometimes. Now, if you need functions as values then you should absolutely use an object for that. So in objects, these functions are then called methods and you can use the this keyword to access properties of the same object, which is impossible in maps. Also, when working with JSON data, you will probably be using objects for that as well


------------------------------------------------------------------------------------------------------------------
// A Closer Look at functions //

-- How Passing Arguments Works: Value vs. Reference 

Passing a primitive type to a function is really just the same as creating a copy, outside of the function. So the value is simply copied.
On the other hand, when we pass an object to a function, it is really just like copying an object. And so whatever we change in a copy will also happen in the original.

-- First-Class and Higher-Order Functions
A higher order function is either a function that receives another function as an argument, or a function that returns a new function.

The callback functions. We do not call them ourselves. But instead we call JavaScript to basically tell them later.

Why our callback functions so much used in JavaScript and why are they so helpful?
Well, the first big advantage of this is that it makes it easy to split up or code into more reusable and interconnected parts.

But there is a second and way more important advantage, which is the fact that callback functions allow us to create abstraction.
what abstraction means, is that we hide the detail of some code implementation because we don't really care about all that detail. And this allows us to think about problems at a higher more abstract level.

-- The call and apply Methods
We use them to specify from where this keyword should takee values

  functionName(flightNum, name) {
  this.someArrayInTheObject.push({
      flight: `${this.airline} flight ${this.iataCode}${flightNum}`,
      name,
    });
  },
functionName.call(Name of the objects, arguments);

Apply works the same but instead of writing arguments one at the time, it takes an array
functionName.apply(Name of the object, array);

We can use call even if we need to put in the array
functionName.call(Name of the object, ...array)

-- The Bind Method
const variableName = function.bind(objectName);


partial application means that a part of the arguments of the original function are already applied, so which means, already set.

const variableName = function.bind(objectName,23);


document
  .querySelector('.buy')
  .addEventListener('click', lufthansa.buyPlane.bind(lufthansa));
Without bind method this keyword would refer to the element on which handler(addEventListener) is attached to

-- Immediately Invoked Function Expressions (IIFE)

It's important to hide variables. And scopes are a good tool for doing this. And this is also the reason why The Immediately Invoked Function Expressions were invented.

-- Closures
So a function always has access to the variable environment of the execution context in which it was created, even after a debt execution context is gone. And this last part is really important. The closure is then basically this variable environment attached to the function, exactly as it was at the time and place that the function was created.

Closure has PRIORITY over the scope chain

Closure is the closed over variable environment of the execution context in which a function was created even after that execution context is gone, or in other words, even after the function to which the execution context belongs has returned.

Closure gives a function access to all the variables of its parent function. So the function in which it is defined even after that parent function has returned. So the function keeps a reference to its outer scope even after that outer scope is gone, which basically preserves the scope chain throughout time.

Closure makes sure that a function does never lose connection to the variables that existed at the function's birthplace. It remembers the variables, even after the birthplace is gone. It's like a person who doesn't lose connection to their hometown. In this analogy, the person is the function and the hometown is the function's parents scope, and the function then doesn't lose the connection to the variables stored in this parent's scope.

Finally, some people like to think of this attached variable environment as a backpack. So in this analogy, a function has a backpack, which it carries around wherever it goes. And this backpack contains all the variables that were present in the environment in which the function was created. Then whenever a variable can't be found in the function scope, JavaScript will look into the backpack and take the missing variable from there.

Also, there is no way for us to explicitly access closed over variables. That's because closures are not like a tangible thing. They're not like an object or so that we can access. So we cannot just reach into a closure and take variables from it. That's impossible because a closure is just an internal property of a function.

-----------------------------------------------------------------------------------------------------
// Working With Arrays //

--Simple Array Methods

SPLICE - mutates original array

-- forEach()

We can use forEach method instead of for loop. Differences are when we use entries in loop we have index,value, but in forEach method we have value,index,entire array/map

forEach() can be used for arrays maps and sets

--  Data Transformations: map, filter, reduce

map returns a new array containing the results of applying an operation on all original array elements

filter returns a new array containing the array elements that passed a specified test condition

reduce boils ("reduces") all array elements down to one single value(e.g. adding all elements together)